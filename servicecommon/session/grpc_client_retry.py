import time

import grpc


class GrpcClientRetry():
    """
    A class aiding in the retrying of grpc methods, allowing for the services
    on the other end to come up and down while client code is trying to call
    them, and the client code requires results.

    No entity wrapping a socket is created in constructing this object.
    gRPC entities wrapping sockets (channels) are created for each attempt
    at a single gRPC method call.  This allows for the retry logic supported
    by this class to withstand the services on the other end going up and down.
    """

    # Tied for Public Enemy #5 for too-many-arguments
    # pylint: disable=too-many-arguments
    # Tied for Public Enemy #8 for too-many-instance-attributes
    # pylint: disable=too-many-instance-attributes
    def __init__(self, service_name, service_stub, logger, host, port,
                 timeout_in_seconds=30, poll_interval_seconds=15,
                 max_message_length=-1, limited_retry_set=None,
                 limited_retry_attempts=3):
        """
        :param service_name: a string for the name of the service,
                            used for logging
        :param service_stub: a reference to the grpc code-generated class
                            for the client service Stub. For instance,
                            a service generated by grpc from a file called
                            foo.proto for a service called "Bar" will have
                            its service stub be references as
                            foo_pb2_grpc.BarStub
        :param logger: A logger reference to log to
        :param host: The host which is hosting the service
        :param port: The port on the host for the service
        :param timeout_in_seconds: A timeout given for any gRPC call to fail.
                            Timeouts longer than 1 minute will likely
                            be subject to other os-level socket timeouts
                            which are not modifiable at this level of API.
        :param poll_interval_seconds: length of time in seconds methods
                            on this class will wait before retrying connections
                            or specific gRPC calls. Default to 15 seconds.
        :param max_message_length: Maximum size in bytes of a response from
                            the service being called. By default this is -1,
                            which according to the gRPC docs indicates that
                            there is no limit to the message size receivable
                            on this client end of the connection.
        :param limited_retry_set: A set of GRPC StatusCodes which will have
                            limited ability to retry.
                            None by default, indicating that any error has
                            unlimited retries.
        :param limited_retry_attempts: the limited number of retries for the
                            StatusCodes in the limited_retry_set before raising
                            the exception upstream.  Default is 3.
        """

        self.service_name = service_name
        self.service_stub = service_stub
        self.logger = logger
        self.host = host
        self.port = port
        self.timeout_in_seconds = timeout_in_seconds
        self.poll_interval_seconds = poll_interval_seconds
        self.max_message_length = max_message_length
        self.connect_timeout_seconds = 15
        self.limited_retry_set = limited_retry_set
        self.limited_retry_attempts = limited_retry_attempts
        self.channel = None
        if self.limited_retry_set is None:
            # Empty set
            self.limited_retry_set = set()


    def must_connect(self):
        """
        Keeps trying to connect to the service indefinitely until
        an attempt is successful.

        Upon success, the GRPC channel is left open so further communications
        can continue.

        Callers are responsible for calling close_channel() on this instance.

        :return: If the single connection attmept is successful,
                an instance of the gRPC stub service with the socket/channel
                connected is returned.
        """

        stub_instance = None
        while stub_instance is None:

            try:
                stub_instance = self._connect_to_service()

            except KeyboardInterrupt:
                # Allow for command-line quitting
                self.close_channel()
                raise

            except grpc.FutureTimeoutError:
                # Retry
                pass

            if stub_instance is None:

                # Close the channel now so we get a fresh one next time around.
                self.close_channel()

                # Log the problem and wait to try again.
                err = "Retrying initial connection to {0} in {1} secs."
                self.logger.warning(err, self.service_name,
                                    self.poll_interval_seconds)

                time.sleep(self.poll_interval_seconds)

            # We want to leave the channel open if the connect is successful.

        return stub_instance

    def must_have_response(self, method_name, rpc_call_from_stub, *args):
        """
        Keeps trying to connect to the gRPC service to make a single
        gRPC call.  Attempts will continue indefinitely until
        an attempt is successful with a non-None response by the gRPC call.

        Each attempt is made with a new socket/channel to the service,
        allowing for the service on the other end to go up and down.

        :param method_name: a string name for the gRPC method invoked
                    used for logging purposes.
        :param rpc_call_from_stub: a global-scope method whose signature looks
                    like this:

            def _my_rpc_call_from_stub(stub, timeout_in_seconds, *args):
                response = stub.MyRpcCall(*args, timeout=timeout_in_seconds)
                return response

        :param *args: a list of arguments to pass to the rpc call method.
                    Even if the gRPC call only takes a single argument,
                    you must put that single argument in a list like this:
                    [ my_one_arg ]

        :return: When a gRPC method call attmept is successful,
                    the instance of the response for that call is returned.
        """

        num_attempts = 0
        response = None
        while response is None:
            try:
                # Connect with a fresh socket each time we make a request.
                # This allows for the service going down in between retries.
                stub_instance = self.must_connect()

                # It's possible that the above connection can be successful
                # and then the rpc call below is when the service decides to
                # go down. That's OK. the rpc_call_from_stub() will fail, and
                # a new socket will be connected to the new service instance
                # upon the detection of the failure below.

                # Make the rpc call attempt
                response = rpc_call_from_stub(stub_instance,
                                           self.timeout_in_seconds, *args)

            except KeyboardInterrupt as exception:
                # Allow for command-line quitting
                raise exception

            except Exception as exception:

                # See if the error is an RpcError with status codes
                # that are registered as limited-retry.
                if isinstance(exception, grpc.RpcError):
                    #pylint: disable=no-member
                    status_code = exception.code()

                    # Allow exceptions that say our own service is
                    # refusing for shut down purposes.
                    if status_code in self.limited_retry_set \
                        and not self._is_shut_down_refusal(exception):

                        num_attempts = num_attempts + 1
                        if num_attempts == self.limited_retry_attempts:
                            raise

                # Log the problem and wait to try again.
                info = "Info: Exception when calling {0}: {1}. " + \
                      "Retrying in {2} secs."
                info = info.format(method_name, str(exception),
                                   self.poll_interval_seconds)

                self.logger.info(info)

                # Close the channel before sleep to tidy up sooner
                self.close_channel()

                time.sleep(self.poll_interval_seconds)

            finally:
                # Always close the channel
                self.close_channel()

        return response


    def close_channel(self):
        """
        Close the GRPC Channel if one has been opened.
        Allow for this being an older GRPC Channel object
        that might not have the close() method yet.

        This is done for you if you call must_have_response(),
        but if you use must_connect(), you must do this yourself.
        """
        if self.channel is not None:
            if "close" in dir(self.channel):
                self.channel.close()
            self.channel = None


    def _connect_to_service(self):
        """
        Attempt to connect to the service specified in the constructor once.
        :return: If the single connection attmept is successful,
                an instance of the gRPC stub service with the socket/channel
                connected is returned. If the connection is unsuccessful,
                None is returned.
        """

        host_and_port = '{}:{}'.format(self.host, self.port)
        self.logger.info("Connecting to {0} on {1} ...",
                         self.service_name, host_and_port)

        options = [
            ('grpc.max_send_message_length', self.max_message_length),
            ('grpc.max_receive_message_length', self.max_message_length)
        ]

        self.close_channel()
        stub_instance = None
        try:
            # "Channels" are gRPC's wrappers for sockets.
            # For the time being we only support insecure channels
            self.channel = grpc.insecure_channel(host_and_port, options=options)
            grpc.channel_ready_future(self.channel).result( \
                timeout=self.connect_timeout_seconds)

        except grpc.FutureTimeoutError as exception:

            # Log the problem, but let the caller figure out what to do
            # with the failure.
            err = "Failed to connect to {0} on {1}. Got: {2}"
            self.logger.error(err, self.service_name, host_and_port,
                              str(exception))
            self.close_channel()
            raise
        else:
            # Create the service stub that we will return from this method
            # with the successfully connected channel.
            stub_instance = self.service_stub(self.channel)

            # Log connection success
            self.logger.info("Connected to {0} on {1}.", self.service_name,
                             host_and_port)

        return stub_instance


    def _is_shut_down_refusal(self, rpc_error):
        """
        :param rpc_exception: an RPCError
        :return: True if the RPCError can be determined to be a service
                shutdown refusal. False otherwise.
        """

        # Innocent until proven guilty
        is_refusal = False

        # This is to match the string in server_lifetime.py
        search_for = "Service refusing"
        err_str = str(rpc_error)
        if search_for in err_str:
            is_refusal = True

        return is_refusal
