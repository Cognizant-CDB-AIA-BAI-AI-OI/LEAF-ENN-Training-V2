
from framework.domain.network_domain_config import NetworkDomainConfig

from domain.faceAge.msft.azure_faceAge_utils import faceAgeConsts


class faceAgeDomainConfig(NetworkDomainConfig):
    """
    Implementation of the DomainConfig class for the chestxray domain, the
    domain's chance to tell the system about different aspects of data-driven
    configuration.

    A 'DomainConfig' instance for ENN describes the data that's required
    for training and evaluation, including where it is, and how to load it
    and use it.

    Also, a chance is afforded by this class to translate some domain-specific
    parameters into parameters that the service-side NetworkBuilder would
    need to know.

    Each instance is intended to be stateless, and thus no constructor
    is necessary.
    
    """

    def generate_default_info_dict(self, extra_config):
        """
        Generates the default values for the domain-specific configuration
        dictionary.

        :param extra_config: A first stab at a domin-specific configuration
            dictionary, as read-in by build_config().  This will include all
            domain-specific configuration read in, including potentially
            misspelled keys (this class doesn't know what is valid yet at this
            point). This allows for the defaults generated by the method to
            depend on other values, if that is necessary.

        :return: A dictionary of *default* domain-specific configuration, whose
            values will be mixed with what was read in from the config files
            inside the build_config() method.

            Dictionary structure can be whatever you like, because it is only
            domain evaluation code that will be reading this data. Nested
            structures, lists and primitives are OK, however any scalar
            leaf-node data must be simple primitives (like strings, floats,
            ints, booleans) that are easily JSON-able. Specifically: code
            objects are not allowed, as this information goes over the wire
            to the workers.
        """

        consts = faceAgeConsts()

        # When multitask is true, the constructed networks are set up in the
        # same manner as omnigot -- one task per classification.
        # When false, there is only a single task for all classifications
        # This single point of specification has some ripple-effects for other
        # bits of configuration.
        
        #$$$$$$$$$$$$$$$ change start $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
        
        # for multi-class use case set as False
        multitask = extra_config.get("multitask", False)
        
        # for multi-class set number of task as 1
        num_tasks = 1
        
        # for multi class loss_function 
        loss_function = 'categorical_crossentropy'
        
        #$$$$$$$$$$$$$$$ change end $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

        test_augment = extra_config.get("test_augment", None)
        if test_augment is not None:
            test_augment = int(test_augment)
            assert test_augment > 0

        default_image_size = 224
        default_info = {

            # Assuming square images
            "image_size": default_image_size,

            # Number of color channels in each image
            "num_channels": 3,

            # Load the coded constants for the domain and have that data be
            # referenceable via the info dictionary.
            #"diseases": consts.DISEASE_LIST,
            #"disease_sizes": [consts.DISEASE_NUM_CLASSES[x] \
            #                    for x in consts.DISEASE_LIST],

            # When multitask is true, the constructed networks are set up in the
            # same manner as omnigot -- one task per classification.
            # When false, there is only a single task for all classifications
            # This single point of specification has some ripple-effects for
            # other bits of configuration.
            
            
            #$$$$$$$$$$$$$$$ change start $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
            
            # for multi-class just define num_classes, instead of diseases list and disease_sizes
            "num_classes":7,
            
            #$$$$$$$$$$$$$$$ change end $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
            
            
            "multitask": multitask,
            "num_tasks": num_tasks,
            "loss_function": loss_function,

            # When true, augment turns on an image augmentation path in the
            # evaluator
            "augment": False,

            # Number of times to perform data augmentation during on test set
            "test_augment": test_augment,

            # Parameters for using the evolved learning rate (lr)
            "lr_scale": 1.0,
            "lr_floor": 0.0,
            "lr_decay": 10,
            "lr_decay_amount": 0.1,

            # Any additional encoder to use.
            "encoder": None,
            "encoder_layer_name": None,
            "encoder_output_size": None,
            "encoder_weights": None,

            # Whether to enable secondary objective, aka number of parameters
            "enable_alt_obj": False,

            "dummy_fitness": False
        }

        return default_info


    def generate_filename_dict(self, domain_specific_dict):
        """
        Generates filenames of required data files, these names are used to
        determine s3 address for download as well as local basedir and
        enn_cache file paths.  They are also the names of the folders inside
        the any archive (tar.gz) files

        :param domain_specific_dict: The assembled domain-specific configuration
            dictionary, with defaults and read-in values already mixed together.

        :return: A dictionary of domain-specific file configuration information,
            where keys are logical references to data files and values are
            data files whose contents need to make it over to each worker.
        """
        
        #$$$$$$$$$$$$$$$ change start $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
        #change image datafile extension and its name, partition and label pickle name as per your dataset

        filetype = domain_specific_dict.get("filetype", "tar.gz")

        filename_dict = {
            'datafile': "images_224_compressed.%s" % filetype,
            'partition': "py3_chex_partition14_unormalized_cleaned.pickle",
            'labels': "py3_chex_labels14_unormalized_cleaned.pickle"
        }
        
        #$$$$$$$$$$$$$$$ change end $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
        
        return filename_dict


    def determine_num_tasks(self, domain_specific_dict):
        """
        Called by the SessionServer.

        :param domain_specific_dict: The assembled domain-specific configuration
            dictionary, with defaults and read-in values already mixed together.
        :return: An integer representing the number of tasks for the network.
            By default a value of "None" is returned, indicating that the
            value is indicated in the network builder configuration
            directly, or is determined by that config's defaults.

        This method translates some domain-specific configuration information
        into generalized specifications for the inputs and outputs of the
        network.  The information created here gets sent to the service
        to be digested by the network constructor.

        While it is conceivable that what gets specified here could be done
        statically in the builder config file, that, however, can be a bit
        cumbersome, and the programmatic interpretation of a few domain config
        parameters tends to have fewer errors.
        """
        num_tasks = domain_specific_dict['num_tasks']
        return num_tasks


    def determine_input_shapes(self, domain_specific_dict):
        """
        Called by the SessionServer.

        :param domain_specific_dict: The assembled domain-specific configuration
            dictionary, with defaults and read-in values already mixed together.
        :return: A list representing the input shape specifications.
            By default a value of "None" is returned, indicating that the
            value is indicated in the network builder configuration
            directly, or is determined by that config's defaults.

        The input and/or output shapes specification can each take one of
        a few forms:

                1.  A single list that describes a single shape
                    for a single terminal to be used for all tasks.
                    Like this:  [ 128, 128, 1 ]

                2.  A list of lists that describes a different shape
                    for each single-terminal task. Length of the outer
                    list must equal 'num_tasks' in the config for this
                    to be valid. Like this for num_tasks = 3:
                        [ [ 56, 56, 1 ], [ 23, 23, 1 ], [ 4096, 1 ] ]

                    Note that semantically, this *could* describe a
                    common multi-terminal spec for each task when all
                    tasks terminals are the same. Unfortunately this
                    case is indistinguishable from the case described
                    above and any multi-terminal task must use a fully-
                    specified list described in method (3) below,
                    repeats or no.

                3.  A list of lists of lists that describes a different
                    shape for each terminal of a multi-terminal task.
                    Length of the outer list must equal 'num_tasks' in
                    the config for this to be valid.

                    The outer-most list has one entry per task.
                    The middle-most list has one entry per task-terminal,
                    even if any given task only has a single terminal.
                    The inner-most list has one entry per shape dimension
                    for the task-terminal.

                    Like this:  (1st task - 1 terminal,
                                 2nd task - 2 terminals,
                                 3rd task - 3 terminals)
                        [   [ [ 4096, 1 ] ],
                            [ [ 56, 56, 1 ], [ 23, 23, 1 ] ],
                            [ [ 256, 256, 1 ], [ 56, 56, 1 ], [ 18, 1 ] ]
                        ]
        Specifically for the chestxray domain, the num_tasks from the config
        informs how many tasks are necessary to construct. For this domain, we
        assume a single input terminal and single output terminal per task.
        The (square) image_size and num_channels are used for the shape
        information for the inputs. The disease_sizes and diseases lists inform
        the shape of the outputs for each task.

        This method translates some domain-specific configuration information
        into generalized specifications for the inputs and outputs of the
        network.  The information created here gets sent to the service
        to be digested by the network constructor.

        While it is conceivable that what gets specified here could be done
        statically in the builder config file, that, however, can be a bit
        cumbersome, and the programmatic interpretation of a few domain config
        parameters tends to have fewer errors.
        """

        input_size = 224
        """
        if domain_specific_dict['encoder'] is None:
            # In this case, the core model takes the raw image data as input.

            # Assuming that the service side can duplicate the single
            # input specified here for all tasks.
            image_size = domain_specific_dict['image_size']

            # Use Form (1) above for the input shape specification.
            # However many tasks we have, they all have the same number of input
            # terminals (one) and each terminal has the same shape.
            input_shapes = [image_size,
                            image_size,
                            domain_specific_dict['num_channels']]

        else:
            # In this case, an existing image model provides an initial encoding.

            input_size = domain_specific_dict['encoder_output_size']
            # Using None here so that appropriate value can be inferred by
            # service.
"""
        #$$$$$$$$$$$$$$$ change start $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
        # define input shape here 
        input_shapes = [input_size, input_size, 3]
        
        #$$$$$$$$$$$$$$$ change end $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

        return input_shapes


    def determine_output_shapes(self, domain_specific_dict):
        """
        Called by the SessionServer.

        :param domain_specific_dict: The assembled domain-specific configuration
            dictionary, with defaults and read-in values already mixed together.
        :return: A list representing the output shape specifications.
            By default a value of "None" is returned, indicating that the
            value is indicated in the network builder configuration
            directly, or is determined by that config's defaults.

        The input and/or output shapes specification can each take one of
        a few forms:

                1.  A single list that describes a single shape
                    for a single terminal to be used for all tasks.
                    Like this:  [ 128, 128, 1 ]

                2.  A list of lists that describes a different shape
                    for each single-terminal task. Length of the outer
                    list must equal 'num_tasks' in the config for this
                    to be valid. Like this for num_tasks = 3:
                        [ [ 56, 56, 1 ], [ 23, 23, 1 ], [ 4096, 1 ] ]

                    Note that semantically, this *could* describe a
                    common multi-terminal spec for each task when all
                    tasks terminals are the same. Unfortunately this
                    case is indistinguishable from the case described
                    above and any multi-terminal task must use a fully-
                    specified list described in method (3) below,
                    repeats or no.

                3.  A list of lists of lists that describes a different
                    shape for each terminal of a multi-terminal task.
                    Length of the outer list must equal 'num_tasks' in
                    the config for this to be valid.

                    The outer-most list has one entry per task.
                    The middle-most list has one entry per task-terminal,
                    even if any given task only has a single terminal.
                    The inner-most list has one entry per shape dimension
                    for the task-terminal.

                    Like this:  (1st task - 1 terminal,
                                 2nd task - 2 terminals,
                                 3rd task - 3 terminals)
                        [   [ [ 4096, 1 ] ],
                            [ [ 56, 56, 1 ], [ 23, 23, 1 ] ],
                            [ [ 256, 256, 1 ], [ 56, 56, 1 ], [ 18, 1 ] ]
                        ]

        This method translates some domain-specific configuration information
        into generalized specifications for the inputs and outputs of the
        network.  The information created here gets sent to the service
        to be digested by the network constructor.

        While it is conceivable that what gets specified here could be done
        statically in the builder config file, that, however, can be a bit
        cumbersome, and the programmatic interpretation of a few domain config
        parameters tends to have fewer errors.
        """
        
        #$$$$$$$$$$$$$$$ change start $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
        # Output shape specification
        output_shapes = [7]
        
        #$$$$$$$$$$$$$$$ change end $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
        """
        if domain_specific_dict['multitask']:
            # For multitask we use Form (2) above
            output_shapes = []
            for disease_size in domain_specific_dict['disease_sizes']:
                output_shape = [disease_size]
                output_shapes.append(output_shape)
        else:
            # For single-task we use Form (1) above
            output_shapes = [len(domain_specific_dict['diseases'])]
            
        """

        return output_shapes
