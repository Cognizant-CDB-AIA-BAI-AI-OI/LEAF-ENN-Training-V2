
import os

from framework.domain.config import Config
from framework.domain.domain_config import DomainConfig


class AbstractDomainConfig(DomainConfig):
    """
    Abstract class whose domain-specific implementations reflect a domain's
    chance to tell the system about different aspects of data-driven
    configuration.

    A 'DomainConfig' instance describes the data that's required
    for training and evaluation, including where it is, and how to load it
    and use it.

    Also, a chance is afforded by this class to translate some domain-specific
    parameters into parameters that the service-side Builder would need to know.

    Each instance is intended to be stateless, and thus no constructor
    is necessary.
    """


    def build_config(self, dict_reference, verbose=False):
        """
        Called by the Session Server to build up the domain-specific
        configuration.  This method ends up calling other abstract
        methods such as generate_default_info_dict() and
        generate_filename_dict() to return the completed dictionary.

        :param dict_reference: A reference to a dictionary to use as a basis.
                This can either be a filename reference or a dictionary itself.
        :param verbose: Controls how chatty the process is. Default False.
        :return: a config dictionary with any missing defaults filled in.
        """

        # Create the default config
        default_config = self.get_default_evaluation_common_config()

        # Call the superclass to create a dictionary of domain-specific
        # parameters read in from the config file.
        config_loader = Config()
        config = config_loader.read_config(dict_reference,
                                           default_config=default_config,
                                           extra_config_key='extra_config')

        # Anything that was not mentioned in the default config will get
        # put into an 'extra_config' sub-dictionary.  Get that, but clear it
        # out so it doesn't propagate out.
        extra_config = config.get('extra_config', {})
        config['extra_config'] = None

        # Let the domain have a chance at programatically creating
        # its default dictionary.
        info = self.generate_default_info_dict(extra_config)

        # If there are other keys in the config file, populate those on the
        # info dict.
        info.update(extra_config)
        config['info'] = info
        if verbose:
            print("domain info: {0}".format(str(info)))

        # Add the domain data filename section to the config dictionary
        config['filename_dict'] = self.generate_filename_dict(info)

        return config


    def generate_default_info_dict(self, extra_config):
        """
        Generates the default values for the domain-specific configuration
        dictionary.

        :param extra_config: A first stab at a domin-specific configuration
            dictionary, as read-in by build_config().  This will include all
            domain-specific configuration read in, including potentially
            misspelled keys (this class doesn't know what is valid yet at this
            point). This allows for the defaults generated by the method to
            depend on other values, if that is necessary.

        :return: A dictionary of *default* domain-specific configuration, whose
            values will be mixed with what was read in from the config files
            inside the build_config() method.

            Dictionary structure can be whatever you like, because it is only
            domain evaluation code that will be reading this data. Nested
            structures, lists and primitives are OK, however any scalar
            leaf-node data must be simple primitives (like strings, floats,
            ints, booleans) that are easily JSON-able. Specifically: code
            objects are not allowed, as this information goes over the wire
            to the workers.

            By default, this generic implementation returns an empty dictionary
            with no defaults, as we dont'know anything about the domain-
            specifics at this level.
        """
        return {}


    def generate_filename_dict(self, domain_specific_dict):
        """
        :param domain_specific_dict: The assembled domain-specific configuration
            dictionary, with defaults and read-in values already mixed together.

        :return: A dictionary of domain-specific file configuration information,
            where keys are logical references to data files and values are
            data files whose contents need to make it over to each worker.

            By default, this generic implementation returns an empty dictionary
            with no defaults, as we dont'know anything about the domain-
            specifics at this level.
        """
        return {}


    def generate_builder_config_add_ons(self, domain_config):
        """
        :param domain_config: Domain-specific configuration dictionary.
        :return: a dictionary that will be used to update() the builder
                config dictionary sent to the service
        """
        return {}


    def get_default_evaluation_common_config(self):
        """
        Prepares a default dictionary for evaluation configuration
        that is used by the common evaluation code on the worker
        (i.e. what is in framework.client_script.client.py)
        """

        # data_basedir defines where the main data directory is. The data
        # directory contains the files need for training and testing.
        # By default it's defined by the env variable
        # DEEPBILEVEL_DATAFILE_DIR, and if not set it defaults to the
        # ~/enn_datacache directory.
        # data_basedir is usually overridden in each experiment domain config,
        # that points it to an S3 bucket. For instance, data_basedir =
        # http://s3.us-west-2.amazonaws.com/ml-enn/deepbilevel_datafiles/omniglot
        # That way no files need to be copied locally.
        data_basedir = "~/enn_datacache"
        if "DEEPBILEVEL_DATAFILE_DIR" in os.environ:
            data_basedir = os.environ["DEEPBILEVEL_DATAFILE_DIR"]

        default_config = {

            # Set to true to not load the data, for testing purposes
            # (not needed?)
            'dummy_load': False,

            # If resolving s3 urls locally, we download the datafiles to
            # this directory
            'local_data_cachedir': "~/enn_datacache",

            # data_basedir defines where the main data directory is. The data
            # directory contains the files need for training and testing.
            'data_basedir': data_basedir,

            # Set to false if the data has already been packaged inside the
            # docker image.
            'send_data': True,

            # Default values moved over from NetworkBuilder that pertain
            # to any domain, but are really only used by evaluation.
            'verbose': False,

            'gpu_mem_frac': None,

            'stop_cond': {
                'min_improve_hist_length': 999,
                'min_improvement': 0,
                'timeout_seconds': 999999
            },

            # Domains can set this in their config files to get out from
            # under legacy naming conventions.
            'evaluator_class_name': None,

            # Whether clients should return dummy results instead of really
            # evaluating the chromosomes. Dummy results are hardcoded results
            # with a random fitness. Use for testing chromosome generation and
            # evolution.
            # 'real' - Real evaluation. Dummy results are not enabled
            # 'load_random' - We get dummy results w/ random fitness
            #           and we construct the domain's evaluator
            # 'load_zero' - We get dummy results w/ zero fitness
            #           and we construct the domain's evaluator
            # 'random' - We get dummy results w/ random fitness
            #           and we do not construct the domain's evaluator
            # 'zero' - We get dummy results w/ zero fitness
            #           and we do not construct the domain's evaluator
            'dummy_run': 'real'
        }

        return default_config
